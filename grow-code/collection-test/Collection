Collection 是集合当中站在最顶层的类,它是一个接口,它的下一级分为:Set接口和List接口,划分了集合的两大家族.

Iterator:迭代器(适用于任何集合)
    ArrayList<String> list = new ArrayList<String>();
    Iterator iterator = list.iterator();
    Iterator主要的两个方法:
        iterator.hasNext(): 返回值为一个bool值,判断集合当中是否还有下一个元素
        iterator.next:提取集合当中的下一个元素
========================================================================================================================
java 5之后,增强了for循环:
    for(数据类型  变量名 : 数组或集合){
        //遍历
    }
========================================================================================================================
集合的通配符: Collection<?>
使用通配符的注意事项:仅次于遍历,不能用于操作.任何类型的集合都可以
集合的限定:
        <? extends Fu>  //这种限制的是父类,上线限定,可以传递Fu以及传递它的子类,向下走
        <? super Fu>  //限制的是子类,下线限定,可以传递Fu以及传递它的父类,向上走
========================================================================================================================
【List集合】
List集合,继承Collection接口,List之下有很多的实现类:ArrayList/LinkedList
List集合派系的三大特性:
    1,有序:可以对列表中每个元素的插入位置进行精确控制
    2,带有索引:用户可以根据元素的整数索引(在列表中的位置)访问元素,并搜索列表中的元素
    3,允许重复:可以存储重复的元素

========================================================================================================================

集合并发异常:ConcurrentModificationException ---并发修改异常
    这个异常产生的原因是,对集合进行遍历的过程中,使用了集合方法,修改了集合的长度,这样是不允许的.(通过迭代器遍历会造成这样的结果)

========================================================================================================================
【List集合存储数据的结构】
数据存储的常用结构:堆栈/队列/数组/链表
    堆栈:采用这种结构的集合,具备以下特征
        1,先进后出(即,存入的元素,必须要在它后面存储的元素取出之后,它才能被取出)
            例如:子弹入膛,先进去的子弹,往往都是后面才被打出去;
        2,栈的入口,出口都是栈的最顶端
        3,压栈:就是存元素,把元素存储到栈的顶端位置,栈中已有的元素,依次向下移动一个单位
        4,弹栈:就是取元素,把栈的顶端元素取出,栈中已有的元素,依次向上移动一个单位
    队列:
        1,先进先出,例如过安检
        2,队列的入口,出口各占一侧
    数组:
        1,查找元素快,通过索引可以快速访问指定位置的元素
        2,增删元素慢(增/删都是重新传建一个数组进行操作的)
            1,指定索引位置增加元素:需要创建一个新的数组,将指定新元素存储在指定索引位置,
              再把原数组元素根据索引,复制到新数组对应索引的位置上
            2,指定索引位置删除元素:创建新数组,只不过不把指定位置的元素复制到新数组当中
    链表:
        1,多个节点通过地址进行连接.
            例如:多个人手拉手,不能断开
        2,查找元素慢,想要查找元素,需要通过连接的节点,依次向后查找指定的元素
        3,增删快
            增加元素/删除元素都只需要修改修改连接下个元素的地址就可以了，不需要破坏原有的结构
========================================================================================================================
ArrayList : LinkedList
    前者采用的就是数组结构,后者链表结构,所以特征很明显,ArrayList集合,查询快,增删慢.LinkedList集合,查询慢,增删快

【【想调用子类特有的功能,就不能用多态】】
LinkedList集合:
    addFirst(E):添加到链表的开头
    addLast(E):添加到链表的结尾
    getFirst()
    getLast()
    ...
注意:LinkedList集合提供了很多对集合头/尾操作的方法,毕竟增删快.

Vector 和 ArrayList 是一类的,都是采用的数组结构,但是Vector是十分古老的,java1.0版本就有,List是1.2才开发出来,
但是他和ArrayList最本质的区别还是在于,Vector是线程安全的,意味着慢,所以后面被ArrayList取代了,淡出了历史舞台

========================================================================================================================
第一天集合的总结:
    Collection集合是站在集合当中的最顶层类,他的下面分为两大派系,List集合/Set集合.List集合与Set集合的差异主要在三个方面:
        1,有序;2,有索引;3,存储的元素可以重复.这三点与Set集合正好相反.List集合存储数据的结构有四种:堆栈/队列/数组/链表
        ArrayList集合采用的是数组结构进行存储数据,LinkedList集合采用的是链表结构.数组结构和链表结构的区别主要体现在于
        查找和增删元素上.数组结构,每个元素都有对应的索引值所以查找快,但是增删慢,因为增删是一个重新创建数组的过程.但是
        链表结构是每一个元素与接近的两个元素地址值的连接,导致查询元素的时候需要通过每个节点的地址值进行查找,很慢,不过
        它的增删元素很快,不需要重新创建数组,只需要对指定位置的元素地址进行更换就可以了.
        Vector集合,是一个在java1.0版本就有的集合,他的出现早于List集合,他也是采用的数组结构,如今已经被ArrayList所替代
========================================================================================================================

Set集合派系的特征最大的特征就是不允许存储重复的元素,通过对象的hashCode()和equals方法,来判断是否为重复元素.
Set集合是没有索引的,所以它的遍历只能通过:迭代器,增强for;
Set集合的类有很多,但是用的最广泛的还是:HashSet和LinkedHashSet这两个集合.

HashSet集合:
    筛选出重复数据的底层原理,通过 hashCode(),equals()两种方法进行判断筛选的
    (当equals()被重写时,通常有必要重写hashCode方法,以维护hashCode方法的常规协定,该协定声明相等对象必须具有相等的哈希码.)
    重写 equals()方法:
        public boolean equals(Object obj){
            if(obj == null){
                return false;
            }
            if(this == obj){
                return true;
            }
            if(obj instanceof Person){
                Person p = (Person) obj;
                return name.equals(p.name) && age == p.age;
            }
            return false;
        }

LinkedHashSet集合,这个集合继承自HashSet集合,但是他是有序的,它采用的是双链接.但是同样的不能够有重复的数据.
========================================================================================================================
ArrayList集合可以通过contains方法判断元素是否重复,这个contains()方法的本质也是通过equals来进行判断的
HashSet集合由于是无序的,所以他判断的唯一依据就是HashCode()和equals()方法的返回结果


集合分为两座金字塔,金字塔的顶端分别是:Collection和Map
    他们的区别主要在于:存储数据的形式不同
        Collection中的集合称为单列集合
        Map中的集合称为双列集合
    需要注意的,Map中的集合不能包含重复的键,但是值可以重复,每个键只能对应一个值
    Map中常用的集合:HashMap集合 / LinkedHashMap集合
========================================================================================================================
【Map集合】:
    双列集合,双泛型
        Map<K,V> map = new HashMap<>();//这种定义是多态格式,Map是一个接口,不能进行new,所以只能new他的子类/实现类
            K:是键值,任意类型,但是在定义之前一定要注意hashCode()和equals(),键值要求唯一.
            V:是值,任意类型,不要求唯一


☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
Collection和Collections的区别
    Collection是集合类的上级接口,继承他的接口主要有Set和List.
    Collections是针对集合类的一个帮助类,他提供一系列静态方法实现对各种集合的搜索/排序/线程安全化等操作.
    Collections没有实现任何接口,他直接继承了Object

    如果两个对象的哈希值相同,他们的equals一定为true吗?
        答案:不一定 (HashCode的常规协定,由Sun公司官方规定)
    如果两个对象的equals为true,他们的哈希值一定相等吗?
        答案:一定   (HashCode的常规协定,由Sun公司官方规定)
		
		
		
		
		
		
/*
	查询,对结果集进行排序
	升序,降序,对指定列排序
	order by 列名 [desc]/[asc]
	desc 降序
	asc  升序排列,可以不写,是默认的
*/
-- 查询账务表,价格进行升序
SELECT * FROM zhangwu ORDER BY zmoney;   -- 升序,默认
SELECT * FROM zhangwu ORDER BY zmoney DESC;  -- 降序
-- 查询账务表,查询所有的支出,并对金额降序排列
-- 先过滤条件 where 查询得到的结果在进行排序!!!
SELECT * FROM zhangwu WHERE zname LIKE '%支出%' ORDER BY zmoney DESC;






